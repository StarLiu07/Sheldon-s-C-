#include<iostream>
using namespace std;

//构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
/*构造函数语法：类名(){}
* 1.构造函数时，没有返回值也不写void
* 2.函数名称与类名相同
* 3.构造函数可以有参数，因此可以发生重载
* 4.程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次
*/

//析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作
/*析构函数语法:~类名(){}
1.析构函数，没有返回值也不写void
⒉函数名称与类名相同,在名称前加上符号~
3.析构函数不可以有参数，因此不可以发生重载
4.程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次*/

//构造函数进行初始化操作
class person1
{
public:
	//1.构造函数
	/*构造函数语法：类名(){}
	* 1.构造函数时，没有返回值也不写void
	* 2.函数名称与类名相同
	* 3.构造函数可以有参数，因此可以发生重载
	* 4.程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次
	*/
	person1()
	{
		cout << "person构造函数的调用" << endl;
	}

	//2.析构函数进行清理的操作
	/*析构函数语法:~类名(){}
	1.析构函数，没有返回值也不写void
	⒉函数名称与类名相同,在名称前加上符号~
	3.析构函数不可以有参数，因此不可以发生重载
	4.程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次*/
	~person1()
	{
		cout << "person析构函数的调用" << endl;
	}
};



//构造和析构都是必须要有的实现，如果我们自己不提供，那么编译器会提供一个空实现的构造和析构
void test01a()
{
	person1 p;//这里并没有调用构造函数，但运行时出现了，说明构造函数自动调用
}

int main1() {

	//test01();
	person1 p;

	system("pause");

	return 0;
}